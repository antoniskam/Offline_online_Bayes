classdef ERANataf

% Generation of joint distribution objects. 
% Construction of the joint distribution object with
%
% Obj = ERANataf(M,Correlation)
%
% 'M' must be an ERADist class with vector shape which contains all the
% marginal distributions that define the joint distribution.
%
% 'Correlation' must be a correlation matrix with shape [d,d], where d is
% the number of marginal distributions (dimensions) of the joint
% distribution. The matrix describes the dependency between the different
% marginal distributions. According to the general definition of a 
% correlation matrix, the input matrix must be symmetric, the matrix entries
% on the diagonal must be equal to one, all other entries (correlation
% coefficients) can have values between -1 and 1.

%{
---------------------------------------------------------------------------
Developed by:
Antonios Kamariotis (antonis.kamariotis@tum.de)
Sebastian Geyer
Felipe Uribe
Iason Papaioannou
Daniel Straub

Assistant Developers:
Luca Sardi
Nicola Bronzetti
Alexander von Ramm
Matthias Willer
Peter Kaplan

Engineering Risk Analysis Group
Technische Universitat Munchen
www.bgu.tum.de/era
---------------------------------------------------------------------------
New Version 2020-10:
* Consistent input and output matrices with dimensions [n,d], where n
  represents the number of samples and d the number of dimensions of the
  joint distribution
* Fixing the descriptions in 'help ERANataf'
* Adding additional error messages for discrete marginals in X2U and
  incorrect correlation matrix inputs 
New Version 2020-01: 
* Fixing of bugs in the transformation from X to U and vice versa
* Alternative calculation of the Nataf joint CDF in high dimensions 
Version 2017-04:
* License check for optimization toolbox -> Use of fsolve if available
* Changes to reduce the required memory
---------------------------------------------------------------------------
* This software performs the Nataf transformation of random variables.
* It is possible to generate random numbers according to their Nataf
joint pdf and to evaluate this pdf.
* The inverse Nataf transformation is also defined as a function.
* It requires the use of Objects of the class ERADist which is also
published on the homepage of the ERA Group of TUM.
---------------------------------------------------------------------------
References:

1. Liu, Pei-Ling and Armen Der Kiureghian (1986) - Multivariate distribution
   models with prescribed marginals and covariances.
   Probabilistic Engineering Mechanics 1(2), 105-112

2. Documentation of the ERA Distribution Classes

---------------------------------------------------------------------------
%}
    
    %% MATLAB class: definition of the 'properties' block
    properties
        Rho_X         % Correlation matrix of the vector X
        Rho_Z         % Correlation matrix of the correlated normal vector Z
        A             % Lower triangular matrix of the Cholesky decomposition of Rho_Z
        Marginals     % Contains all marginal distribution objects
    end
    
    %% MATLAB class: definition of the 'methods' block
    %{
    Definition of all member functions of the ERANataf class. Those are:
   - ERANataf   (Constructor)
   - X2U        samples from physical to standard
   - U2X        samples from standard to physical
   - random     Generates random numbers according to their joint pdf
   - pdf        Evaluaters the joint pdf of a sample vector
    %}
    methods
        
        % The constructor transforms the Correlation matrix Rho_x to Rho_Z.
        % Furthermore it evaluates whether Rho_Z is positive definite. 
        % Matlab will exit the code if that is not the case.
        % A is the lower triangular matrix generated by the cholesky
        % decomposition such that Rho_Z = A*A'.
        function Obj = ERANataf(M,Correlation)
        
            Obj.Marginals = M;
            n_dist        = length(M);
            Obj.Rho_X     = Correlation;
            
            % Check if distributions are second order
            for i = 1:n_dist
                if ~(isfinite(M(i).mean) && isfinite(M(i).std))
                    error('The marginal distributions need to have finite mean and variance');
                end
            end
            
            % Check if input for correlation matrix fulfills requirements
            % perform Choleski decomposition
            [~,flag] = chol(Obj.Rho_X,'lower');
            if flag ~= 0 % checking positive definitness of correlation matrix
                error('The given correlation matrix is not positive definite --> Nataf transformation is not applicable');
            end
            if ~all(Obj.Rho_X == Obj.Rho_X','all') % checking symmetry of correlation matrix (is not done by chol)
                error('The given correlation matrix is not symmetric --> Nataf transformation is not applicable');
            end
            
            if ~all(diag(Obj.Rho_X) == 1) % checking if matrix entries on the diagonal are equal to one
                error('Not all diagonal entries of the correlation matrix are equal to one --> Nataf transformation is not applicable');
            end
            
            % Calculation of the transformed correlation matrix. This is achieved by a
            % quadratic two-dimensional Gauss-Legendre integration
            zmax = 8;       % Integration bounds
            zmin = -zmax;   % Integration bounds
            n    = 1024;    % number of integration points along each dimension
            
            % Legendre-Gauss nodes and weights  on the interval [zmin,zmax]
            [points,w_1D] = quad_GL(n,zmin,zmax);
            
            xi    = reshape(repmat(points,1,n)',[n^2,1]);
            eta   = repmat(points,n,1);
            w_2D  = reshape(repmat(w_1D,1,n)',[n^2,1]).*repmat(w_1D,n,1);
            
            % check if Rho_X is identity matrix
            Obj.Rho_Z = eye(n_dist);
            if norm(Obj.Rho_X-eye(n_dist)) >= 1e-5   % samples are uncorrelated
                
                % This loop construction makes sure that no unnecessary
                % calculations are done -> Only off-diagonal elements of the upper part of
                % the matrix are calculated -> afterwards they are copied to the lower part
                % options = optimoptions(@fsolve,'Display','off');
                options   = optimset('Display','off');
                for i = 1:n_dist
                    for j = i+1:n_dist
                        if Obj.Rho_X(i,j) == 0
                            continue;
                        end
                        if strcmp(M(i).Name,'standardnormal') && strcmp(M(j).Name,'standardnormal')
                            Obj.Rho_Z(i,j) = Obj.Rho_X(i,j);
                            Obj.Rho_Z(j,i) = Obj.Rho_Z(i,j);
                            continue;
                        elseif strcmp(M(i).Name,'normal') && strcmp(M(j).Name,'normal')
                            Obj.Rho_Z(i,j) = Obj.Rho_X(i,j);
                            Obj.Rho_Z(j,i) = Obj.Rho_Z(i,j);
                            continue;
                        elseif strcmp(M(i).Name,'normal') && strcmp(M(j).Name,'lognormal')
                            Vj             = M(j).std/M(j).mean;
                            Obj.Rho_Z(i,j) = Obj.Rho_X(i,j)*Vj/sqrt(log(1+Vj^2));
                            Obj.Rho_Z(j,i) = Obj.Rho_Z(i,j);
                            continue;
                        elseif strcmp(M(i).Name,'lognormal') && strcmp(M(j).Name,'normal')
                            Vi             = M(i).std/M(i).mean;
                            Obj.Rho_Z(i,j) = Obj.Rho_X(i,j)*Vi/sqrt(log(1+Vi^2));
                            Obj.Rho_Z(j,i) = Obj.Rho_Z(i,j);
                            continue;
                        elseif strcmp(M(i).Name,'lognormal') && strcmp(M(j).Name,'lognormal')
                            Vi             = M(i).std/M(i).mean;
                            Vj             = M(j).std/M(j).mean;
                            Obj.Rho_Z(i,j) = log(1+Obj.Rho_X(i,j)*Vi*Vj)/sqrt(log(1+Vi^2)*log(1+Vj^2));
                            Obj.Rho_Z(j,i) = Obj.Rho_Z(i,j);
                            continue;
                        end
                        % solving Nataf
                        
                        % Transformation of parameters of the distributions for the
                        % matlab cdf/icdf functions and calculations of those
                        tmp_f_xi = (M(j).icdf(normcdf(eta))-M(j).mean)/M(j).std;
                        tmp_f_eta = (M(i).icdf(normcdf(xi))-M(i).mean)/M(i).std;
                        coef = tmp_f_xi.*tmp_f_eta.*w_2D;
                        
                        fun  = @(rho0) sum(coef.*1/(2*pi*sqrt(1-rho0^2)).*exp( -1/(2*(1-rho0^2))*...
                            (xi.^2 - 2*rho0*xi.*eta + eta.^2) ))-Obj.Rho_X(i,j);
                        
                        [xs,~,exitflag] = fzero(fun,Obj.Rho_X(i,j),options);
                        if exitflag > 0
                            Obj.Rho_Z(i,j) = xs;
                            Obj.Rho_Z(j,i) = Obj.Rho_Z(i,j);
                        else
                            fun = @(rho0) sum(coef.*1/(2*pi*sqrt(1-rho0^2)).*exp( -1/(2*(1-rho0^2)) *...
                                (xi.^2 - 2*rho0*xi.*eta + eta.^2) ))-Obj.Rho_X(i,j);
                            [xs,~,exitflag] = fzero(fun,-Obj.Rho_X(i,j),options);
                            if exitflag > 0
                                Obj.Rho_Z(i,j) = xs;
                                Obj.Rho_Z(j,i) = Obj.Rho_Z(i,j);
                            elseif license('test', 'optimization_toolbox')
                                
                                [xs,~,exitflag] = fsolve(fun,Obj.Rho_X(i,j),options);
                                
                                if exitflag > 0
                                    Obj.Rho_Z(i,j) = xs;
                                    Obj.Rho_Z(j,i) = Obj.Rho_Z(i,j);
                                else
                                    [xs,~,exitflag] = fsolve(fun,-Obj.Rho_X(i,j),options);
                                    
                                    if exitflag > 0
                                        Obj.Rho_Z(i,j) = xs;
                                        Obj.Rho_Z(j,i) = Obj.Rho_Z(i,j);
                                    else
                                        % Try random initial values for fsolve
                                        for k=1:10
                                            init=2*rand-1;
                                            [xs,~,exitflag] = fsolve(fun,init,options);
                                            if exitflag>0
                                                break
                                            end
                                        end
                                        
                                        if exitflag>0
                                            Obj.Rho_Z(i,j) = xs;
                                            Obj.Rho_Z(j,i) = Obj.Rho_Z(i,j);
                                        else
                                            % No convergence, exit Nataf
                                            error('fzero and fsolve could not converge to a solution of the Nataf integral equation');
                                        end
                                    end
                                end
                            else
                                
                                % Try random initial values for fzero
                                for k=1:10
                                    init=2*rand-1;
                                    [xs,~,exitflag] = fzero(fun,init,options);
                                    if exitflag>0
                                        break
                                    end
                                end
                                
                                if exitflag>0
                                    Obj.Rho_Z(i,j) = xs;
                                    Obj.Rho_Z(j,i) = Obj.Rho_Z(i,j);
                                else
                                    % No convergence, exit Nataf
                                    error('fzero could not converge to a solution of the Nataf integral equation');
                                end
                            end
                        end
                    end
                end
            end
            % perform Choleski decomposition
            [Obj.A,p] = chol(Obj.Rho_Z,'lower');
            if p ~= 0
                error('Transformed correlation matrix is not positive definite --> Nataf transformation is not applicable');
            end
        end
        
        %-----------------------------------------------------------------------
        % This function performs the transformation from X to U by taking
        % the inverse standard normal cdf of the cdf of every value. Then
        % it performs the transformation from Z to U. A is the lower
        % triangular matrix of the cholesky decomposition of Rho_Z and
        % U is the resulting independent standard normal vector
        % Afterwards it calculates the Jacobian of this Transformation if
        % it is needed.
        
        function [U,Jac] = X2U(Obj,X,opt)
            % Carries out the transformation from physical space X to
            % standard normal space U.
            %
            % U = X2U(Obj,X,opt)
            %
            % X must be a [n,d]-matrix (n = number of data points, d = 
            % dimensions).
            % The output Jac is only given if the input opt is given as 
            % character array 'Jac'. If that is the case, the output Jac
            % corresponds to the Jacobian of the transformation of the
            % first sample.
            %
            
            n_dim = length(Obj.Marginals); % number of dimensions of the joint distribution
            
            % check if all marginal distributions are continuous
            for i = 1:n_dim
                switch lower(Obj.Marginals(i).Name)
                    case {'binomial','geometric','negativebinomial','poisson'}
                        error('At least one of the marginal distributions is a discrete distribution, the transformation X2U is therefore not possible.')
                end
            end
            
            % check of the dimensions of input X
            if size(X,2) == 1 && n_dim ~= 1 % in case that only one point X is given, he can be defined either as row or column vector
                X = X';
            end
            if size(X,2) ~= n_dim
                error('X must be an array of size [n,d], where d is the number of dimensions of the joint distribution.') 
            end
            
            n_X = size(X,1);
            Z = zeros(n_dim,n_X);
            for i = 1:n_dim
                Z(i,:) = norminv(Obj.Marginals(i).cdf(X(:,i)));
            end
            U = (Obj.A\Z)';
            
            % Jacobian of X to U for the first sample
            if nargin == 2
                Jac = [];
            elseif strcmp('Jac',opt) == 1
                diag = zeros(n_dim);
                for i = 1:n_dim
                    diag(i,i) = normpdf(Z(i,1))/Obj.Marginals(i).pdf(X(1,i));
                end
                Jac = diag*Obj.A;
            else
                error('Wrong Input');
            end
            
        end
        
        %-----------------------------------------------------------------------

        function [X,Jac] = U2X(Obj,U,opt)
            % Carries out the transformation from standard normal space U 
            % to physical space X .
            %
            % X = U2X(Obj,U,opt)
            %
            % U must be a [n,d]-matrix (n = number of data points, d =
            % dimensions).
            % The output Jac is only given if the input opt is given as 
            % character array 'Jac'. If that is the case, the output Jac
            % corresponds to the Jacobian of the transformation of the
            % first sample.
            %
            
            n_dim = length(Obj.Marginals); % number of dimensions of the joint distribution
            
            % check of the dimensions of input X
            if size(U,2) == 1 && n_dim ~= 1 % in case that only one point X is given, he can be defined either as row or column vector
                U = U';
            end
            if size(U,2) ~= n_dim
                error('U must be an array of size [n,d], where d is the number of dimensions of the joint distribution.') 
            else
                U = U';
            end
            Z     = Obj.A*U;
            n_U = size(U,2);
            
            X = zeros(n_U,n_dim);
            for i = 1:n_dim
                X(:,i) = Obj.Marginals(i).icdf(normcdf(Z(i,:)));
            end
            
            % Jacobian of U to X for the first sample
            if nargin == 2
                Jac = [];
            elseif strcmp('Jac',opt) == 1
                diag = zeros(n_dim);
                for i = 1:n_dim
                    diag(i,i) = Obj.Marginals(i).pdf(X(1,i))/normpdf(Z(i,1));
                end
                Jac = Obj.A\diag;
            else
                error('Wrong Input');
            end
        end
        
        %-----------------------------------------------------------------------
        % This function generates random numbers according to their joint
        % distribution
        function jointrandom = random(Obj,n)
            % Creates n samples of the joint distribution.
            % Every row in the output matrix corresponds to one sample.
            %
            % jointrandom = random(Obj,n)
            %
            
            n_dim = length(Obj.Marginals); % number of dimensions of the joint distribution
            
            U           = randn(n_dim,n);
            
            Z           = Obj.A*U;
            jointrandom = zeros(n,n_dim);
            for i = 1:n_dim
                jointrandom(:,i) = Obj.Marginals(i).icdf(normcdf(Z(i,:)));
            end
        end
        
        %-----------------------------------------------------------------------
        
        function jointpdf = pdf(Obj,X)
            % Computes the joint PDF.
            %
            % jointpdf = pdf(Obj,X)
            %
            % X must be a [n,d]-matrix (n = number of data points, d =
            % dimensions).
            %
            
            n_dim = length(Obj.Marginals); % number of dimensions of the joint distribution
            
            % check if all marginal distributions are continuous
            for i = 1:n_dim
                switch lower(Obj.Marginals(i).Name)
                    case {'binomial','geometric','negativebinomial','poisson'}
                        error('At least one of the marginal distributions is a discrete distribution, the computation of the joint PDF is currently not supported.')
                end
            end            
            
            % check of the dimensions of input X
            if size(X,2) == 1 && n_dim ~= 1 % in case that only one point X is given, he can be defined either as row or column vector
                X = X';
            end
            if size(X,2) ~= n_dim
                error('X must be an array of size [n,d], where d is the number of dimensions of the joint distribution.')
            end
            
            n_X = size(X,1);
            U    = zeros(n_X,n_dim);
            phi  = zeros(n_dim,n_X);
            f    = zeros(n_dim,n_X);
            mu   = zeros(1,n_dim);
            for i = 1:n_dim
                U(:,i)   = norminv(Obj.Marginals(i).cdf(X(:,i)));
                phi(i,:) = normpdf(U(:,i));
                f(i,:)   = Obj.Marginals(i).pdf(X(:,i));
            end
            phi_n    = mvnpdf(U,mu,Obj.Rho_Z);   % multivariate with mean 0 std 1 and corr Rho_Z
            jointpdf = zeros(n_X,1);
            for i = 1:n_X
                jointpdf(i) = (prod(f(:,i),1)/prod(phi(:,i),1))*phi_n(i);
                if isnan(jointpdf(i)) == 1
                    jointpdf(i) = 0;
                end
            end
        end
        
        %-----------------------------------------------------------------------
        
        function jointcdf = cdf(Obj,X)
            % Computes the joint CDF.
            %
            % jointpdf = pdf(Obj,X)
            %
            % X must be a [n,d]-matrix (n = number of data points, d =
            % dimensions).
            %
            
            n_dim = length(Obj.Marginals); % number of dimensions of the joint distribution
            
            % check of the dimensions of input X
            if size(X,2) == 1 && n_dim ~= 1 % in case that only one point X is given, he can be defined either as row or column vector
                X = X';
            end
            if size(X,2) ~= n_dim
                error('X must be an array of size [n,d], where d is the number of dimensions of the joint distribution.')
            end
            
            n_X = size(X,1);
            U    = zeros(n_X,n_dim);
            mu   = zeros(1,n_dim);
            for i = 1:n_dim
                U(:,i) = norminv(Obj.Marginals(i).cdf(X(:,i)),0,1);
            end
            
            % the matlab built-in mvncdf works only up to n<=25 if SIGMA is
            % specified
            if n_dim <= 25 || isequal(Obj.Rho_Z,eye(n_dim))
                if Obj.Rho_Z == eye(n_dim)
                    jointcdf = mvncdf(U,mu);
                else
                    jointcdf = mvncdf(U,mu,Obj.Rho_Z);
                end
            else
                s = mvncdf_alt(-inf(1,n_dim),U,Obj.Rho_Z,1);
                jointcdf = s.prob;
            end
        end
    end
    
end

%% nested function: Gauss-Legendre quadrature
function [x,w] = quad_GL(N,a,b)
%{
Written by Greg von Winckel - 02/25/2004
This script is for computing definite integrals using Legendre-Gauss
Quadrature. Computes the Legendre-Gauss nodes and weights  on an interval
[a,b] with truncation order N

Suppose you have a continuous function f(x) which is defined on [a,b]
which you can evaluate at any x in [a,b]. Simply evaluate it at all of
the values contained in the x vector to obtain a vector f. Then compute
the definite integral using sum(f.*w);
%}
N  = N-1;
N1 = N+1;
N2 = N+2;
xu = linspace(-1,1,N1)';
%
y  = cos((2*(0:N)'+1)*pi/(2*N+2))+(0.27/N1)*sin(pi*xu*N/N2);   % Initial guess
L  = zeros(N1,N2);   % Legendre-Gauss Vandermonde Matrix
Lp = zeros(N1,N2);   % Derivative of LGVM

% Compute the zeros of the N+1 Legendre Polynomial
% using the recursion relation and the Newton-Raphson method
y0 = 2;

% Iterate until new points are uniformly within epsilon of old points
while max(abs(y-y0))>eps
    L(:,1)  = 1;
    L(:,2)  = y;
    Lp(:,1) = 0;
    Lp(:,2) = 1;
    for k = 2:N1
        L(:,k+1) = ( (2*k-1)*y.*L(:,k)-(k-1)*L(:,k-1) )/k;
    end
    Lp = (N2)*( L(:,N1)-y.*L(:,N2) )./(1-y.^2);
    y0 = y;
    y  = y0-L(:,N2)./Lp;
end

% Linear map from [-1,1] to [a,b]
x = (a*(1-y)+b*(1+y))/2;

% Compute the weights
w = (b-a)./((1-y.^2).*Lp.^2)*(N2/N1)^2;

end

function  est=mvncdf_alt(l,u,Sig,n)
% computes an estimator of the probability Pr(l<X<u),
% where 'X' is a zero-mean multivariate normal vector
% with covariance matrix 'Sig', that is, X~N(0,Sig)
% infinite values for vectors 'u' and 'l' are accepted;
% Monte Carlo method uses sample size 'n'; the larger
% the 'n', the smaller the relative error of the estimator;
% output: structure 'est' with
%              1. estimated value of probability Pr(l<X<u)
%              2. estimated relative error of estimator
%              3. theoretical upper bound on true Pr(l<X<u)
%              Remark: If you want to estimate Pr(l<Y<u),
%                   where Y~N(m,Sig) has mean vector 'm',
%                     then use 'mvncdf(Sig,l-m,u-m,n)'.
% Example: (run from directory with saved mvncdf.m)
% clear all,clc,d=25;
% l=ones(d,1)/2;u=ones(d,1);
% Sig=inv(0.5*eye(d)+.5*ones(d,d));
% est=mvncdf(l,u,Sig,10^4) % output of our method
%
% % Executing Matlab's toolbox\stats\stats\mvncdf.m
% % with n=10^7 below is slow and inaccurate
% cd(matlabroot) % change to Matlab default path
% options=optimset('TolFun',0,'MaxFunEvals',10^7,'Display','iter');
% [prob,err]=mvncdf(l,u,zeros(d,1),Sig,options)

% Reference:
% Z. I. Botev (2015),
% "The Normal Law Under Linear Restrictions:
%  Simulation and Estimation via Minimax Tilting",
%  submitted to JRSS(B)
l=l(:); u=u(:); % set to column vectors
d=length(l); % basic input check
if  (length(u)~=d)|(d~=sqrt(prod(size(Sig)))|any(l>u))
    error('l, u, and Sig have to match in dimension with u>l')
end
% Cholesky decomposition of matrix
[L, l, u]=cholperm( Sig, l, u ); D=diag(L);
if any(D<eps)
    warning('Method may fail as covariance matrix is singular!')
end
L=L./repmat(D,1,d);u=u./D; l=l./D; % rescale
L=L-eye(d); % remove diagonal
% find optimal tilting parameter via non-linear equation solver
options=optimset('Diagnostics','off','Display','off',...
    'Algorithm','trust-region-dogleg','Jacobian','on');
[soln,fval,exitflag] = fsolve(@(x)gradpsi(x,L,l,u),zeros(2*(d-1),1),options);
if exitflag~=1
    warning('Method may fail as covariance matrix is close to singular!')
end
x=soln(1:(d-1));mu=soln(d:(2*d-2)); % assign saddlepoint x* and mu*
est=mvnpr(n,L,l,u,mu);
% compute psi star
est.upbnd=exp(psy(x,L,l,u,mu));
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function est=mvnpr(n,L,l,u,mu)
% computes P(l<X<u), where X is normal with
% 'Cov(X)=L*L' and zero mean vector;
% exponential tilting uses parameter 'mu';
% Monte Carlo uses 'n' samples;
d=length(l); % Initialization
mu(d)=0;
Z=zeros(d,n); % create array for variables
p=0;
for k=1:(d-1)
    % compute matrix multiplication L*Z
    col=L(k,1:k)*Z(1:k,:);
    % compute limits of truncation
    tl=l(k)-mu(k)-col;
    tu=u(k)-mu(k)-col;
    %simulate N(mu,1) conditional on [tl,tu]
    Z(k,:)=mu(k)+trandn(tl(:),tu(:));
    % update likelihood ratio
    p = p+lnNpr(tl,tu)+.5*mu(k)^2-mu(k)*Z(k,:);
end
% deal with final Z(d) which need not be simulated
col=L(d,:)*Z;tl=l(d)-col;tu=u(d)-col;
p=p+lnNpr(tl,tu); % update LR corresponding to Z(d)
p=exp(p); % now switch back from logarithmic scale
est.prob=mean(p);
est.relErr=std(p)/sqrt(n)/est.prob; % relative error
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function p=psy(x,L,l,u,mu)
% implements psi(x,mu); assumes scaled 'L' without diagonal;
d=length(u);x(d)=0;mu(d)=0;x=x(:);mu=mu(:);
% compute now ~l and ~u
c=L*x;l=l-mu-c;u=u-mu-c;
p=sum(lnNpr(l,u)+.5*mu.^2-x.*mu);
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [grad,J]=gradpsi(y,L,l,u)
% implements gradient of psi(x) to find optimal exponential twisting;
% assumes scaled 'L' with zero diagonal;
d=length(u);c=zeros(d,1);x=c;mu=c;
x(1:(d-1))=y(1:(d-1));mu(1:(d-1))=y(d:end);
% compute now ~l and ~u
c(2:d)=L(2:d,:)*x;lt=l-mu-c;ut=u-mu-c;
% compute gradients avoiding catastrophic cancellation
w=lnNpr(lt,ut);
pl=exp(-0.5*lt.^2-w)/sqrt(2*pi);
pu=exp(-0.5*ut.^2-w)/sqrt(2*pi);
P=pl-pu;
% output the gradient
dfdx=-mu(1:(d-1))+(P'*L(:,1:(d-1)))';
dfdm= mu-x+P;
grad=[dfdx;dfdm(1:(d-1))];
if nargout>1 % here compute Jacobian matrix
    lt(isinf(lt))=0; ut(isinf(ut))=0;
    dP=-P.^2+lt.*pl-ut.*pu; % dPdm
    DL=repmat(dP,1,d).*L;
    mx=-eye(d)+DL;
    xx=L'*DL;
    mx=mx(1:d-1,1:d-1);
    xx=xx(1:d-1,1:d-1);
    J=[xx,mx';
        mx,diag(1+dP(1:d-1))];
end
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function x=trandn(l,u)
% samples a vector of length=length(l)=length(u)
% from the standard multivariate normal distribution,
% truncated over the region [l,u];
% input 'l' and 'u' are column vectors;
% inifinite values for 'u' and 'l' are accepted
x=nan(size(l));
a=.66; % treshold for switching between methods
% threshold can be tuned for maximum speed for each platform
% three cases to consider:
% case 1: a<l<u
I=l>a;
if any(I)
    tl=l(I); tu=u(I); x(I)=ntail(tl,tu);
end
% case 2: l<u<-a
J=u<-a;
if any(J)
    tl=-u(J); tu=-l(J); x(J)=-ntail(tl,tu);
end
% case 3: otherwise use inverse transform or accept-reject
I=~(I|J);
if  any(I)
    tl=l(I); tu=u(I); x(I)=tn(tl,tu);
end
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function x=ntail(l,u)
% samples a column vector of length=length(l)=length(u)
% from the standard multivariate normal distribution,
% truncated over the region [l,u], where l>0 and
% l and u are column vectors; modification of Marsaglia (1964)
% who uses acceptance-rejection from Rayleigh distr.
c=l.^2/2; n=length(l); f=expm1(c-u.^2/2);
x=c-reallog(1+rand(n,1).*f); % sample using Rayleigh
% keep list of rejected
I=find(rand(n,1).^2.*x>c); d=length(I);
while d>0 % while there are rejections
    cy=c(I); % find the thresholds of rejected
    y=cy-reallog(1+rand(d,1).*f(I));
    idx=rand(d,1).^2.*y<cy; % accepted
    x(I(idx))=y(idx); % store the accepted
    I=I(~idx); % remove accepted from list
    d=length(I); % number of rejected
end
x=sqrt(2*x); % this Rayleigh transform can be delayed till the end
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function x=tn(l,u)
% samples a column vector of length=length(l)=length(u)
% from the standard multivariate normal distribution,
% truncated over the region [l,u], where -a<l<u<a for some
% 'a' and l and u are column vectors;
% uses acceptance rejection and inverse-transform method;
tol=2; % controls switch between methods
% threshold can be tuned for maximum speed for each platform
% case: abs(u-l)>tol, uses accept-reject from randn
I=abs(u-l)>tol; x=l;
if any(I)
    tl=l(I); tu=u(I); x(I)=trnd(tl,tu);
end
% case: abs(u-l)<tol, uses inverse-transform
I=~I;
if any(I)
    tl=l(I); tu=u(I); pl=erfc(tl/sqrt(2))/2; pu=erfc(tu/sqrt(2))/2;
    x(I)=sqrt(2)*erfcinv(2*(pl-(pl-pu).*rand(size(tl))));
end
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function  x=trnd(l,u)
% uses acceptance rejection to simulate from truncated normal
x=randn(size(l)); % sample normal
% keep list of rejected
I=find(x<l|x>u); d=length(I);
while d>0 % while there are rejections
    ly=l(I); % find the thresholds of rejected
    uy=u(I);
    y=randn(size(ly));
    idx=y>ly&y<uy; % accepted
    x(I(idx))=y(idx); % store the accepted
    I=I(~idx); % remove accepted from list
    d=length(I); % number of rejected
end
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function p=lnNpr(a,b)
% computes ln(P(a<Z<b))
% where Z~N(0,1) very accurately for any 'a', 'b'
p=zeros(size(a));
% case b>a>0
I=a>0;
if any(I)
    pa=lnPhi(a(I)); % log of upper tail
    pb=lnPhi(b(I));
    p(I)=pa+log1p(-exp(pb-pa));
end
% case a<b<0
idx=b<0;
if any(idx)
    pa=lnPhi(-a(idx)); % log of lower tail
    pb=lnPhi(-b(idx));
    p(idx)=pb+log1p(-exp(pa-pb));
end
% case a<0<b
I=(~I)&(~idx);
if any(I)
    pa=erfc(-a(I)/sqrt(2))/2; % lower tail
    pb=erfc(b(I)/sqrt(2))/2;  % upper tail
    p(I)=log1p(-pa-pb);
end
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function p=lnPhi(x)
% computes logarithm of  tail of Z~N(0,1) mitigating
% numerical roundoff errors;
p=-0.5*x.^2-log(2)+reallog(erfcx(x/sqrt(2)));
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [ L, l, u, perm ] = cholperm( Sig, l, u )
%  Computes permuted lower Cholesky factor L for Sig
%  by permuting integration limit vectors l and u.
%  Outputs perm, such that Sig(perm,perm)=L*L'.
%
% Reference:
%  Gibson G. J., Glasbey C. A., Elston D. A. (1994),
%  "Monte Carlo evaluation of multivariate normal integrals and
%  sensitivity to variate ordering",
%  In: Advances in Numerical Methods and Applications, pages 120--126

d=length(l);perm=1:d; % keep track of permutation
L=zeros(d,d);z=zeros(d,1);
for j=1:d
    pr=Inf(d,1); % compute marginal prob.
    I=j:d; % search remaining dimensions
    D=diag(Sig);
    s=D(I)-sum(L(I,1:j-1).^2,2);
    s(s<0)=eps;s=sqrt(s);
    tl=(l(I)-L(I,1:j-1)*z(1:j-1))./s;
    tu=(u(I)-L(I,1:j-1)*z(1:j-1))./s;
    pr(I)=lnNpr(tl,tu);
    % find smallest marginal dimension
    [dummy,k]=min(pr);
    % flip dimensions k-->j
    jk=[j,k];kj=[k,j];
    Sig(jk,:)=Sig(kj,:);Sig(:,jk)=Sig(:,kj); % update rows and cols of Sig
    L(jk,:)=L(kj,:); % update only rows of L
    l(jk)=l(kj);u(jk)=u(kj); % update integration limits
    perm(jk)=perm(kj); % keep track of permutation
    % construct L sequentially via Cholesky computation
    s=Sig(j,j)-sum(L(j,1:j-1).^2);s(s<0)=eps;L(j,j)=sqrt(s);
    L(j+1:d,j)=(Sig(j+1:d,j)-L(j+1:d,1:j-1)*(L(j,1:j-1))')/L(j,j);
    % find mean value, z(j), of truncated normal:
    tl=(l(j)-L(j,1:j-1)*z(1:j-1))/L(j,j);
    tu=(u(j)-L(j,1:j-1)*z(1:j-1))/L(j,j);
    w=lnNpr(tl,tu); % aids in computing expected value of trunc. normal
    z(j)=(exp(-.5*tl.^2-w)-exp(-.5*tu.^2-w))/sqrt(2*pi);
end
end